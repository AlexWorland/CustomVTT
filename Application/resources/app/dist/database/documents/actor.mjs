import BaseActor from"../../../common/documents/actor.mjs";import ServerDocumentMixin from"../backend/server-document.mjs";import{setProperty}from"../../../common/utils/helpers.mjs";import{IMAGE_FILE_EXTENSIONS,VIDEO_FILE_EXTENSIONS}from"../../../common/constants.mjs";import Files from"../../files/files.mjs";import{HTMLField}from"../../../common/data/fields.mjs";export default class Actor extends(ServerDocumentMixin(BaseActor)){static async migrateSystem(){globalThis.logger.info("Migrating Actor game system data to the latest Actor data model.");const e=await this.find({});for(let t of e)try{t.updateSource({system:t.migrateSystemData()}),await this.db.updateOne({_id:t.id},t.toObject())}catch(e){globalThis.logger.error(e)}globalThis.logger.info(`Successfully migrated ${e.length} Actors to the latest system data model.`)}static get sanitizedFields(){const e=!!this._sanitizedFields,t=super.sanitizedFields;if(!e)for(let e of game.template.Actor?.htmlFields||[]){setProperty(t,`system.${e}`,new HTMLField)}return t}static socketListeners(e){e.on("requestTokenImages",this.#e.bind(this,e))}static async#e(e,t,{pack:s=null},o){const r=s?db.packs.get(s):db.Actor;if(!r.connected)return o({error:`The ${s} Datastore is not yet connected.`});const i=await r.get(t),a=i?.testUserPermission(e.user,"OWNER");if(!e.user.hasPermission("FILES_BROWSE")&&!a)return o({error:`You do not have permission to query wildcard token images for Actor [${t}].`});const n=i.prototypeToken;if(!n.randomImg)return o({files:[n.texture.src]});const{source:c,pattern:m,browseOptions:d}=Files.parseWildcardPath(n.texture.src);d.isAdmin=!0,d.target=m,d.extensions=Object.keys(IMAGE_FILE_EXTENSIONS).concat(Object.keys(VIDEO_FILE_EXTENSIONS)).map((e=>`.${e}`));config.files.storages[c].getFiles(d).then(o).catch((e=>o({error:e.message})))}}