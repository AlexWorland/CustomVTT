import fs from"fs";import path from"path";import*as documents from"../../common/documents/module.mjs";import{BaseSystem}from"../../common/packages/module.mjs";import{BASE_DOCUMENT_TYPE,PACKAGE_AVAILABILITY_CODES}from"../../common/constants.mjs";import{hasProperty,isEmpty,duplicate,mergeObject,isNewerVersion}from"../../common/utils/helpers.mjs";import ServerPackageMixin,{PackageAssetField}from"./package.mjs";export default class System extends(ServerPackageMixin(BaseSystem)){static defineSchema(){const e=super.defineSchema();return e.background=new PackageAssetField({required:!1,blank:!0,relativeToPackage:!1,mustExist:!1}),e}#e;#t=0;_validateModel(e){this.installed&&System.#a(e.id)}loadDataTemplate(){const e=System.#a(this.id),t=this.#s(e);return{template:e,model:this.#r(e,t),documentTypes:t}}static#a(e){const t=path.join(this.baseDir,e,"template.json");if(!fs.existsSync(t))throw new Error(`The required "template.json" file does not exist for system ${e}`);try{return JSON.parse(fs.readFileSync(t,"utf-8"))}catch(t){throw new Error(`Unable to parse system template for ${e}: ${t.message}`)}}async getUpdateNotification(){const e=Date.now();if(!this.#e||e-this.#t>864e5){const e=await this.constructor.check(this.manifest,this);e.isUpgrade?globalThis.logger.info(`${this.title} update ${e.remote.version} is now available!`):globalThis.logger.info(`No system update for ${this.title} is currently available.`),this.#e={hasUpdate:e.isUpgrade,version:e.remote?.version||null}}return this.#e}async checkUpdateAvailable(){const e=await System.fromRemoteManifest(this.manifest);return isNewerVersion(e.version,this.version)&&e.availability===PACKAGE_AVAILABILITY_CODES.AVAILABLE?e.version:null}#s(e){return Object.values(documents).reduce(((t,a)=>{let s=[BASE_DOCUMENT_TYPE];if(a.schema.has("type")){const t=a.metadata.coreTypes||[],r=a.hasSystemData?e[a.documentName]?.types:[],o=new Set(t.concat(r||[]));o.size&&(s=Array.from(o))}return t[a.documentName]=s,t}),{})}#r(e,t){return db.documents.filter((e=>e.hasSystemData)).reduce(((a,s)=>{const r=e.hasOwnProperty(s.name)?e[s.name]:{},o=!isEmpty(r);return a[s.name]=t[s.name].reduce(((e,t)=>{const a=o?duplicate(r[t]||{}):{};let s={},i=a.templates||[];i=i.filter((e=>hasProperty(r,`templates.${e}`)));for(let e of i)mergeObject(s,r.templates[e],{enforceTypes:!1});return delete a.templates,s=mergeObject(s,a,{inplace:!1,enforceTypes:!1}),e[t]=s,e}),{}),a}),{})}static async install(e,t,a,s){const r=await super.install(e,t,a,s);return packages.World.resetPackages(),r}static async uninstall(e){let t=await super.uninstall(e);return packages.World.resetPackages(),t}}